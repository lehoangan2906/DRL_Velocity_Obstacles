#!/usr/bin/python3
#
# Usage:
#
# This code is used to publish velocity commands (`cmd_vel`) based on the input received 
# from a topic (`/drl_cmd_vel`), which is generated by a DRL planner.
#
# If the robot is following a dynamic goal, ensure that the /drl_cmd_vel topic 
# receives real-time updates reflecting the target's movement.

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

class VelSwitch(Node):
    # Define the VelSwitch class, inheriting from the Node class

    def __init__(self):
        # Initialize the node with the name `mix_cmd_vel`
        super().__init__('mix_cmd_vel')

        # Initialize the velocities
        self.drl_vel_Twist()    # Store the received velocity from DRL planner
        self.cmd_vel_vx = 0.0   # Linear velocity in x-direction
        self.cmd_vel_wz = 0.0   # Angular velocity in z-direction

        # Initialize the ROS2 subscriber and publisher
        self.drl_vel_sub = self.create_subscription(
            Twist,                  # Message type
            '/drl_cmd_vel',         # Topic to subscribe to
            self.drl_callback,      # Callback function when a message is received
            10                      # QoS profile
        )

        self.cmd_vel_sub = self.create_publisher(
            Twist,                  # Message type
            '/cmd_vel',             # Topic to publish to
            10                      # QoS profile
        )

        # Timer to control publishing rate 
        self.rate = 80          # 20 Hz velocity sampling rate

    # Callback function to handle the received DRL velocity message
    def drl_callback(self, drl_vel_msg):
        self.drl_vel = drl_vel_msg  # Store the received velocity message

        # Get the velocity commands from the received message
        self.cmd_vel_vx = self.drl_vel.linear.x
        self.cmd_vel_wz = self.drl_vel.angular.z

        # Create a new Twist message to publish
        cmd_vel = Twist()
        cmd_vel.linear.x = self.cmd_vel_vx
        cmd_vel.angular.z = self.cmd_vel_wz

        # Publish the velocity command
        self.cmd_vel_pub.publish(cmd_vel)

def main(args=None):
    rclpy.init(args=args)   # Initialize the ROS2 communication Node
    vel_switch = VelSwitch()    # Create an instance of the VelSwitch class
    rclpy.spin(vel_switch)  # keep the node alive and responsive
    vel_switch.destroy_node()   # Destroy the node explicitly (optional)
    rclpy.shutdown()        # Shutdown the node

if __name__ == '__main__':
    main()  # Run the main function

